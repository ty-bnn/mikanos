# 日記

### Day02

BootLoaderのビルドのためにedk2の設定を2箇所書き換える必要がある。

- ビルドターゲット設定：edk2/Conf/target.txt（みかん本参照）
- クロスコンパイル設定：edk2/Conf/tools_def.txt（[参照](https://github.com/sarisia/mikanos-docker?tab=readme-ov-file#m1-mac-%E3%81%A7%E3%81%AE%E5%8B%95%E4%BD%9C%E3%81%AF)）

メモリマップをUEFI経由で取得し、特定のメモリ領域に格納。
その後、これまたUEFIの機能を使ってメモリマップの情報をcsv形式で出力。UEFIは割と何でもできる（気がする）。
OSがあればシステムコールを使ってファイルの入出力をするけど、UEFIを使ってファイル操作できるのは驚き。
BootLoaderで出力したcsvファイルは`disk.img`をマウントして確認可能。

### Day03

やっとカーネルを起動する。
BootLoaderのプログラムからUEFI経由でkernel.elfをメモリにロードし、実行の権限をカーネルに移す。

UEFIの機能を使って画面描画をする。
フレームバッファの開始アドレスを取得した後、ピクセル毎に値を書き込む。

UEFIで取得したフレームバッファの情報をカーネルに渡し、カーネル側で画面描画を出来るようにした。

エラーが起きた時に画面にメッセージを出力しておいて以降はhaltするようにした。

### Day04

カーネルのビルドをMakefileに移行。

ピクセルの色彩情報方法を変更。
WritePixel関数を使うことで座標+RGB情報で描画可能に。

ピクセルを描画する処理にC++のクラスを使用。
いよいよC++っぽくなってきた。
まだmallocなどのシステムコールを使用できないため、new演算子のオーバーロードと静的な領域確保によってクラスのインスタンス作成を行う。

BootLoaderを改良した。
元々ELFファイルをそのまま特定のメモリ領域にコピーしていたところ、ELFファイルのプログラムヘッダの情報を基にコピーするように変更。
ELFファイルの情報をもう少し理解したいなあ...

### Day05

`A`のフォントを用意して画面に描画できるようになった。

リファクタリングして機能毎にファイルを分割。
Makefileの書き方はもう少し学ぶ必要あり。

フォントを追加。
テキストファイルからどうやってフォント情報をカーネルに教えるのかなと思っていたが、一旦バイナリにしてからobjcopyコマンドでobjectファイルに変換し、リンクすると他のプログラムから見えるようになるらしい。
他のプログラムからはobjcopyが命名する変数名（`_binary_hankaku_bin_start`など）を使うと操作可能。
これは面白い。

文字列描画とsprintfを追加。

コンソールを出力できるようになった！

printkでカーネル内から気軽に文字列を出力できるようになった。

### Day06

マウスとかバーとかを描画。OSのGUIぽくなってきた。

<img src="img/day06a.png" alt="day06a" width="300">

PCに登録されているPCIデバイスを全て検出することに成功。
IOアドレス空間に存在する全てのバス・デバイス・ファンクションにおけるPCIコンフィギュレーションを取得し出力する。

PCIデバイス(xHCIコントローラ)経由でマウスがつながっているUSBポートを監視し、マウスの動きを描画するようになった。
現状マウスの動きは割り込みではなくポーリング。
カーソルの軌跡は単色で塗りつぶしているため変な跡が残る。

<img src="img/day06c.png" alt="day06c" width="300">